# Core

*`Core`文件夹生成的组件都来自于外部组件项目，其生成方式为调用对应组件项目的描述文件然后生成程序。本文档存在只是为了辅助理解项目，但不一定准确，具体请结合程序文件来理解。*

## 说明

### 组件文件夹命名
1. 在`Core`文件夹中，所有的组件命名方式为：`用户id_组件id_组件英语名`。`用户id`是用户在创建账号的时候就会被分配的一个相对于其它用户唯一id。`组件id`是用户每创建一个组件项目后，该组件项目就会被分配一个对于该用户创建的所有组件项目唯一的id。`组件英语名`是用户在创建组件项目的时候为该项目取的英语名，包括该英语名在内，BUGU中所有的英语名都不是必须的且是可以重复的，如果用户没有对该组件项目创建英语名，则使用`Component`作为默认英语名。
2. BUGU官方的用户id为0。
3. 如果有内部下级组件，内部下级组件将会在上级组件的`组件id`后加上下级组件的`组件id`，该`组件id`是在上级组件中重新排列的。
4. 如果是`移植组件`，则上级移植组件应该在本组件的`组件id`后加上`Trans`，而其下级移植组件则应该在本组件的`组件id`后加上`SubTrans`，移植组件只能以组件项目的方式创建。
5. 所有id存在的目的都是为了在当前分级文件夹或函数变量名中防止重名。

### 基础组件

1. 基础组件是在前端编程时的概念，后端解析其中的内容时会按照特殊的方式去解析。基础组件包括赋值、判断、循环等方法，也包括各种基础数据类型。具体实现会在示例程序中说明，一些操作未在本示例中展示，当前平台需要实现的也只是示例中的内容，其它的操作将在未来逐渐完善。
2. 基础组件在前端不需要手动添加或使用模板添加，当用户进入到编程界面后，侧栏将始终提供基础组件。
3. 基础组件下拥有操作类和数据类两种。操作类自带一个公共对象`基础操作`，用户使用基础操作的方法来实现对程序流程的控制，操作类不能被继承。数据类既是一个单独的类，也是对数据类及其所有子类的统称，如果没有特殊说明，数据类一律理解为统称，数据类可以被继承。

### 侧边栏

1. 在前端，用户将在侧栏中看到组件、类、方法、对象等信息，侧栏分为两个页面，我们将其称之为方法栏和对象栏（对象栏即仓库），分别用于管理组件的类中的方法和对象。
2. 在侧边栏中，用户可以看到已经导入到项目中的组件，当展开组件后，可以看到其所拥有的类和内部下级组件。内部下级组件可以继续如同组件一样展开。在方法栏中，类展开后即会显示当前类定义的所有方法，点击其中某一方法，即可显示该方法定义的所有重载。在对象栏中，类展开后即会显示当前类定义的所有对象，如果当前打开了某一个方法，则还会显示该方法中定义的所有对象。
3. 在侧边栏中，组件需要显示其`名称`、`作者`、`id`。以本文件夹下`0_0_BUGU_HAL`组件为例，用户将会看见组件名称：`标准硬件组件`，同时在旁边显示组件作者名称：`不咕官方`，以及一个组件id：`0`。排布显示方案可以参考vscode的扩展。
4. 和英语名相反，BUGU中所有名称都是必填的且在同一子集下不允许重复，例如用户昵称、组件名称等，但它们可以在不同子集下重复，例如用户A创建名称为`测试1`的组件，用户B也可以创建名称为`测试1`的组件，同时用户A也可以在其名称为`测试2`的组件中创建名为`测试1`的组件，这三者是不会冲突的，但是用户A自己不能在一个已有`测试1`组件的地方创建另一个`测试1`组件。
5. 组件、类、方法和对象的显示内容在侧边栏显示都是一个思路，都必须需要显示名称。区别在于它们的id都是对于其所属的上级的id，例如类id是在其所属组件中进行排列生成的，不同组件的id可以重复。同时，组件需要显示作者，类需要显示组件，方法需要显示所属类，对象既要显示所属类，也要显示创建其使用的类。
6. 在创建组件、类、方法和对象时，都应该记录它们的名称、英语名和注释。
7. 当使用鼠标右键在侧栏中点击某个组件时，可以为其创建类或内部下级组件（也可以放两个按钮点得方便点）。当右键点击某个类时，在方法栏可以创建方法，在对象栏可以创建对象。右键点击方法时可以创建类。
8. 在对象栏直接创建的对象是没有被构造的，它们被称之为虚拟对象，虚拟对象只能使用构造方法，而当期使用了构造方法后才变成实例对象，实例对象才可以使用非构造方法的其它方法。每创建一个新的类时，都会为其自动创建一个构造方法。
9.  使用数据类申请的对象是可以直接在对象栏进行构造，在对象栏中点击某一数据类申请的对象，然后在其后面的构造列中写入一个常量即可。对于非数据类申请的对象或不希望使用常量进行构造的对象，应可以通过构造栏定位到该对象构造的位置，当对象在不同地方使用了构造方法，也应该需要可以分别进行跳转。（这部分功能暂时可以不做）
10. 在组件项目中，侧边栏中的组件分为外部下级组件和内部下级组件，内部下级组件被包含在项目组件中（每个组件项目中必然有一个项目组件，代表它自己）。而在工程项目中，侧边栏中的组件可以分为导入组件和自定义组件，同时可以为自定义组件创建内部下级组件或将其它组件添加为外部下级组件。
11. 侧边栏中的组件中，组件项目的项目组件是自带的，内部下级组件是创建的，而外部下级组件则是导入的。同理，工程项目中的导入组件是导入的，自定义组件时创建的。而导入组件的方式可以有手动导入，或通过项目模板导入，项目模板是用户在创建项目的时候选择的一个模板，目前其功能只有自动帮助导入一些外部的组件。

#### 上级组件和下级组件

1. 下级组件是针对上级组件而言的，当用户导入一个上级组件到侧栏中时，则其所有下级组件也会被导入到侧栏中。
2. 下级组件又分为内部下级组件和外部下级组件，内部下级组件和上级组件的关系类似于包含关系，而外部下级组件和上级组件的关系类似于引用关系。内部下级组件的添加只能是显式的，它等同于在一个组件项目中新建一个附属组件项目。外部下级组件的添加可以是显式地也可以是隐式的，它相当于添加了一个对外部组件项目的引用。
3. 用户如果是在组件项目中：那么他在侧边栏导入外部组件后，即等同于添加了一个外部下级组件。而如果他在侧边栏的项目组件一栏中右键选择新建内部下级组件，那么便等同于为该组件项目的组件添加了一个内部下级组件，编辑方法请查看本项目中各组件内部的介绍。
4. 用户如果是在工程项目中：那么他在侧边栏导入外部组件后，如果在他自定义的组件的某个类中使用了该导入组件中的类来申请对象，那么该导入组件就是该自定义组件的一个外部下级组件。同时他也可以手动选择某个自定义组件，然后选择添加外部下级组件，之后即可将侧边栏中的非该自定义组件或其内部下级组件的其它组件添加为外部下级组件。添加内部下级组件的方法同组件项目，但只要是自定义组件就可以添加。
5. 内部下级组件生成的程序将会放在sub文件夹下。

### 类调用

1. 当A组件的A类在B组件的B类中被申请为对象时，B组件的B类即创建一个类调用列表，并记录A组件的A类的ID。
2. 后端解析将从核心类开始，遍历其类调用列表并找出其所调用的所有类，然后再从这些类中继续向下遍历，直到没有新的类为止。
3. 当一个类调用了其他类，则在生成h文件时需要include该类。
4. 只有被调用了的类才会生成h文件以及其中方法的c文件，只有存在被调用类的组件才会生成对应文件夹，如果是内部下级组件的类被调用，则也应该生成其上级组件的文件夹，哪怕上级组件的类并没有被调用。