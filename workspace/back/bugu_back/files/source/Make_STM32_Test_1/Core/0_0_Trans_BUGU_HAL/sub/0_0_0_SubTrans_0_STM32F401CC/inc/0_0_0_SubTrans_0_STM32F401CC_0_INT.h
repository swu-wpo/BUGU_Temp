/**************************************************************
功能：防止头文件被反复引用导致编译速度过慢或内存溢出
判定内容：本文件的文件名包括后缀全大写，空格和点以下划线代替，前后分别加上两个下划线，此部分还包含了最后的endif
**************************************************************/
#ifndef __0_0_0_SUBTRANS_0_STM32F401CC_0_INT_H__
#define __0_0_0_SUBTRANS_0_STM32F401CC_0_INT_H__

/**************************************************************
功能：便于C++程序的调用
使用方式：在进行了前面的防止重复引用步骤后，直接原样添加此部分内容即可，分为两部分，这是第一部分
**************************************************************/
#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************
功能：引用头文件
使用方法：用户应该可以在前端查看自己提交的SDK文件夹结构，同时能够从其中挑选一些文件，
当在一些可以添加外部引用的地方，例如需要从外部引入类、对象或方法，就可以挑选对应的c和h文件，
h文件将会添加到其它类文件的引用头文件处，而c文件将会作为资源文件在Makefile中添加路径，
此外用户还可以选择添加引用路径，然后将h文件的路径添加到Makefile中，这样添加了引用路径的文件就可以写所添加引用路径的相对路径即可

除此之外还有添加直接通过BUGU生成的h文件和c文件，关于这部分将在后面用到的时候讲述
***************************************************************/
#include "stm32f4xx_ll_exti.h"

// 在前端，当用户希望直接创建一个对象时，需要先在对象栏中指定组件行中选择新建类，然后会出现一个弹窗或页面（以下简称弹窗）
// 在该弹窗中选择所需组件和类，选择后将会显示该类生成对象时所需的基础设置，本示例项目将会在出现新的类型时分别讲述不同类的设置界面

/***************************************************************
对象：种类枚举对象
所属组件：基础组件
继承关系：基础->数据->枚举->种类枚举
简介：种类枚举的功能类似于一种编号，当使用种类枚举的对象时，其每个枚举项都代表一个整数

移植：种类枚举<->enum，BUGU种类枚举可以和C语言标准enum之间相互转换，使用enum将会把数据分配到静态区，其占用RAM量比直接数字的常量高但比普通变量低。

前端：
用户在创建对象时，选择了基础组件中的种类枚举后，即可创建一个种类枚举对象

种类枚举对象的枚举项值可以手动设置，也可以自动添加（即在前端每添加一项时，都会自动在前一项的基础上加一）
但是不论是手动还是自动，都必须显示具体值
枚举项最好可以按照枚举项值大小自动进行排序
在创建对象弹窗中，至少需要提供如下内容：
1.枚举名
2.枚举英语名（可选）
3.枚举简介（可选）
4.枚举项表
枚举项表应该是一个类似于表格形式的内容（当然，也可以是卡片形式的，这个看前端的设计风格）
在枚举项表中，应该可以添加枚举项，并且可以看到已经添加的按顺序排列的枚举项
每个枚举项至少需要提供如下内容：
1.枚举项名
2.枚举项英语名（可选）
3.枚举项简介（可选）
4.枚举项值（可自动生成，但不能为空）
此外，用户还可以选择从sdk中添加enum，此时需要在弹窗中勾选从C文件中引入选项，然后弹窗中将会新增一些选项：
1.添加引用文件（从一个文件浏览目录下选择对应的一个或多个h文件和c文件进行引用，这部分参考前述引用头文件）
2.枚举英语名此时必须填写，且填写的名称必须就是所需添加的C语言中枚举typedef的别名（目前不考虑没别名的情况）
3.枚举项英语名此时必须填写，同时必须和所需添加的枚举中的每个枚举项相同
枚举类及其子类的对象在初始化的时候有两种方式：
1.本体初始化，用户需要在这种初始化时为该枚举创建枚举项，我们可以将这种枚举概念上理解成一个类，如果决定将该枚举本体初始化就必须在对象栏进行初始化。
2.副本初始化，用户需要在这种创建时就为该枚举链接一个本体初始化过的枚举对象，然后该枚举可以通过枚举项id对应上本体枚举的某个枚举值，我们可以将这种枚举概念上理解成一个对象，该对象有一个值，对应着其链接的枚举值。

后端：
当后端解析到此部分内容时，需要生成如下内容——
如果是BUGU自动生成的enum，则需要按照enum的语法来——：
typedef enum
{
    OptionName = OptionVal,
    ...
}EnumName;
其中EnumName的名字按照如下方法进行命名：Object_OptionEnum_类文件名_对象id_枚举英语名
1.Object代表对象
2.OptionEnum代表种类枚举
3.类文件名就是当前文件的名称，主要是为了防止名字在不同文件之间被反复定义
4.对象id是当前类每个对象拥有的一个唯一id，主要是为了防止名字在本文件被反复定义
5.枚举英语名是可选的，如果没有就算了
而OptionName则是在EnumName的基础上增加了一点东西：EnumName_枚举项id_枚举项英语名
1.EnumName就是前面的内容
2.枚举项是在当前枚举中防止被反复定义的id
3.枚举项英语名是可选的，如果没有就算了
而OptionVal就是枚举项值，全部是整数，直接填上去即可
而如果是从外部sdk引用的内容，则需要：
先解析引用文件，并将第一次出现的引用文件添加到前面引用头文件的部分，如果添加过引用路径，且该文件是该引用路径下的文件，则添加相对路径
然后生成内容的时候则是对已有的内容进行重命名，以提供统一的代码风格，重命名方法为：
typedef SDK_EnumName EnumName
#define OptionName SDK_OptionName
其中EnumName和OptionName与前面的内容相同，
而SDK_EnumName和SDK_OptionName则分别是枚举英语名和枚举项英语名，具体参考前面前端部分

下面展示的这个枚举就是从外部引入的
事实上该枚举可以有更多枚举项，但是为了方便我这里没有全部写出来，而在前端编程的时候，这部分其实也可以不全部写出来
***************************************************************/

/***************************************************************
前端填入数据
初始化方式：本体初始化
对象类型：SDK引入种类枚举
对象名：中断类型
对象英语名：IRQn_Type
对象简介：对芯片中所有中断的编号
枚举项表：
0.
枚举项名：系统时钟中断
枚举项英语名：SysTick_IRQn
枚举项简介：Cortex-M4的系统时钟中断
枚举项值：-1
***************************************************************/
typedef IRQn_Type Object_OptionEnum_0_0_0_SubTrans_0_STM32F401CC_0_INT_0_IRQn_Type;
#define Object_OptionEnum_0_0_0_SubTrans_0_STM32F401CC_0_INT_0_IRQn_Type_0_SysTick_IRQn SysTick_IRQn

/***************************************************************
对象：数据枚举对象
所属组件：基础组件
继承关系：基础->数据->枚举->数据枚举
简介：考虑到C语言enum和种类枚举只能列出整数，而且它们会一定量损耗内存空间大小，为了更加节省内存，我们可以使用数据枚举来直接完成一些基础数据的赋值

前端：
在前端定义数据枚举和种类枚举基本一致，但区别在于数据枚举可以设置类型和宽度
例如我们可以设置一个数据枚举叫常用数学值，然后为其添加pi和e的值，此时只需要将数据类选为浮点类即可
目前支持该功能的有8位、16位、32位（有符号/无符号)整数类（共计6种）和单/双精度浮点数类（共计2种）
同时用户在填写的时候还可以选择使用八进制或十六进制进行填写
除此之外数据枚举对象还可以直接以宏的方式引入数据，具体参考本组件的CLK类文件
而且这些数据类还有一个特点就是可以直接在对象栏种进行初始化（赋初值）（但不止这8种）

后端：
后端在解析数据枚举类的对象时，可以参考种类枚举对象，它们的区别在于：
1.OptionEnum->DataEnum
2.没有typedef的enum，对象只是在概念上存在，实际使用的就是具体的枚举项
3.枚举项值必须进行强制转换来变为规定值
4.枚举项值可以有浮点数
5.枚举项在前端用的什么进制就生成为什么进制
***************************************************************/

/***************************************************************
前端填入数据
初始化方式：本体初始化
对象类型：BUGU数据枚举
对象名：中断优先级分组
对象英语名：NVIC_PRIORITYGROUP
对象简介：NVIC中断优先级分组
枚举类型：无符号32位整数
填写进制：十六进制
枚举项表：
0.（只举一例，后面递推）
枚举项名：0位抢占4位相应
枚举项英语名：0P4S
枚举项简介：
枚举项值：0x00000007(因为是32位整数，所以前端十六进制会辅助自动显示8位填写位置，同理如果是8位整数，就会显示2位填写位置)

 ！注意，这里本来可以有简介，但是如果感觉枚举项名已经说清楚了，也可以不填（事实上写没写清楚都可以不填）
***************************************************************/
#define Object_DataEnum_0_0_0_SubTrans_0_STM32F401CC_0_INT_1_NVIC_PRIORITYGROUP_0_0P4S ((uint32_t)0x00000007)
#define Object_DataEnum_0_0_0_SubTrans_0_STM32F401CC_0_INT_1_NVIC_PRIORITYGROUP_1_1P3S ((uint32_t)0x00000006)
#define Object_DataEnum_0_0_0_SubTrans_0_STM32F401CC_0_INT_1_NVIC_PRIORITYGROUP_2_2P2S ((uint32_t)0x00000005)
#define Object_DataEnum_0_0_0_SubTrans_0_STM32F401CC_0_INT_1_NVIC_PRIORITYGROUP_3_3P1S ((uint32_t)0x00000004)
#define Object_DataEnum_0_0_0_SubTrans_0_STM32F401CC_0_INT_1_NVIC_PRIORITYGROUP_4_4P0S ((uint32_t)0x00000003)

/**************************************************************
创建方法/重载
在BUGU平台中，方法是一个概念，而重载才是真正的执行步骤，对象执行任何方法的时候，其实都是选择了方法的一个重载进行执行。

前端：
当用户需要创建方法时，需要在方法栏选择某个组件的某个类然后选择新建方法，
而新建方法后需要至少新建一个重载，选择需要创建重载的方法选择新建重载，然后会跳出一个弹窗或界面（以下统称弹窗），填写一些基础设置
用户在弹窗中至少需要填写如下内容：
1.方法名
2.方法英语名（可选）
3.方法简介（可选）
4.形参表
其中形参表是一个表格或卡片（前端决定），填写的是该方法所需的参数对象
这些参数对象在编写方法时将会被视为一个已实例化的对象来使用
对于形参表中各对象，至少需要填写如下内容：
1.对象类型（从侧栏已有的组件->类中选择）
2.对象名
3.对象英语名（可选）
4.对象简介（可选）
5.对象默认值（可选）
6.对象取值区间（自动）
其中前四项我们结合前面的内容已经可以理解，主要讲一下后两项：
对象默认值有点类似于C++设置默认值，不过在BUGU中设置的默认值在前端是可视的，但在后端生成是不可视的
当一个参数对象可以设置默认值且参数作者为其设置了默认值后，那么在使用该方法时，这个默认值会在方法被添加的时候被直接添加
而取值区间则是为参数对象的取值设置一个区间，当使用方法的时候如果需要使用常量或选项进行取值，则只能在这个区间取值
不过考虑到全能性，用户也可以通过一个开关来关闭某一个对象的取值区间，此时用户即可在该对象完整取值区间内进行取值
例如1字节的无符号整型，整个取值区间就可以取0-255，但如果加上取值区间，它可能就只能取0-12和23
在不修改的情况下，对象取值区间自动添加最大取值区间
对象默认值和取值区间都是在前端展示的，后端不需要在意或进行任何实现。
这两个功能目前不需要完全完整实现，暂时只需要实现本示例项目中提及的内容即可

如果是一个SDK的函数被引入设置为方法，那么其引入方式是直接使用：
#define FuncName(Param...) SDK_FuncName(Param...)
其中FuncName的命名方式为：
Func_类文件名_方法id_方法英语名_重载id_Extern
其中类文件名、方法id、方法英语名、重载id参考前面枚举对象部分，Extern表示这是一个从外部SDK引入的方法
在弹窗中应该有开关标志方法为外部引入，当打开后方法英语名为必填，且需要引入文件，具体参考前面，不过参数的对象英语名可以不填
Param是参数列表，命名方式是：
xFormParam_类型代号_参数id_参数名
其中xFormParam表示这是个形式参数，x则有两种——I和O
I表示输入参数，O表示输出参数，不过考虑到有些参数概念上既是作为了输入，也是作为了输出，故有时候我们可以视情况更改称呼
I表示副本参数，即方法运行只影响副本不影响传入本体，而O表示本体参数，表示会直接影响到本体
这两种称呼都是正确的，只是为了适应不同情况下的不同概念，不过在前端显示的时候使用副本参数和本体参数这一对名字。
类型代号是对一些基础数据类的代号，使代码更易阅读理解，例如无符号32位整数，代号即是U32，而如果是数据枚举，则是DataEnum
参数id和参数名概念参考其它id和名

需要注意的是，如果引入的方法是一个有返回值的方法，那么其返回值在宏定义的时候应该传给第一个本体参数，而宏定义内容也会变成赋值语句
所以需要一个开关记录是否引入了一个有返回值的方法，后端接受到信息后就会生成对应格式，而且在前端也需要特殊表示这个返回值本体参数
具体可以参考下面几个方法，它们都是引入方法
**************************************************************/

/**************************************************************
前端填入数据
方法类型：SDK引入方法（后续依靠define定义的方法如果没有特殊说明，都是SDK引入方法）
方法名：优先级分组设置
方法英语名：NVIC_SetPriorityGrouping
方法简介：设置当前芯片已解锁可使用的优先级分组
形参表：
0.
对象类型：基础组件->数据枚举
链接枚举对象：当前组件->当前类->中断优先级分组
对象名：中断优先级分组
对象英语名：PriorityGroup
对象简介：
对象默认值：4
对象取值区间：0-4

！注意：因为是方法的形参，枚举子类的初始化方式只有副本枚举，这里不用显示填写。而链接对象链接完成后，
对象取值区间会直接自动根据链接的本体枚举拥有的枚举项为其列出枚举项，事实上这里会用枚举名列出，但是
为了方便我这里直接用id写。用户可以将一些枚举项在取值区间中叉掉，此时用户在使用该方法的时候就不能直
接使用已被叉掉的取值，除非使用外部传入的对象或者通过开关关闭限制。
**************************************************************/
#define Func_0_0_0_SubTrans_0_STM32F401CC_0_INT_0_NVIC_SetPriorityGrouping_0_Extern(IFormParam_DataEnum_0_PriorityGroup) NVIC_SetPriorityGrouping(IFormParam_DataEnum_0_PriorityGroup)
/**************************************************************
前端填入数据：
形参表：
0.
对象类型：基础组件->种类枚举
链接枚举对象：当前组件->当前类->中断类型
对象名：中断类型
对象英语名：IRQn_Type
对象简介：
对象默认值：0
对象取值区间：0-0

1.
对象类型：基础组件->无符号32位整数类
对象名：优先级
对象英语名：Priority
对象简介：
对象默认值：
对象取值区间：0-4294967295（32位整数能取到的最大值）
**************************************************************/
#define Func_0_0_0_SubTrans_0_STM32F401CC_0_INT_1_NVIC_SetPriority_0_Extern(IFormParam_OptionEnum_0_IRQn_Type, IFormParam_U32_1_Priority) NVIC_SetPriority(IFormParam_OptionEnum_0_IRQn_Type, IFormParam_U32_1_Priority)
#define Func_0_0_0_SubTrans_0_STM32F401CC_0_INT_2_NVIC_EncodePriority_0_Extern(IFormParam_U32_0_PriorityGroup, IFormParam_U32_1_PreemptPriority, IFormParam_U32_2_SubPriority, OFormParam_U32_3_EncodePriority) *OFormParam_U32_3_EncodePriority = NVIC_EncodePriority(IFormParam_U32_0_PriorityGroup, IFormParam_U32_1_PreemptPriority, IFormParam_U32_2_SubPriority)
/**************************************************************
此处方法是引入方法，且其SDK中的函数是有返回值的，所以此处我们使用输出参数来表示该返回值，并展示如何使用宏定义来表现该返回值。
前端填入数据：
1.
对象类型：基础组件->无符号32位整数类
对象名：优先级
对象英语名：Priority
对象简介：
对象默认值：
对象取值区间：0-4294967295（32位整数能取到的最大值）
**************************************************************/
#define Func_0_0_0_SubTrans_0_STM32F401CC_0_INT_3_NVIC_GetPriorityGrouping_0_Extern(OFormParam_U32_0_PriorityGroup) *OFormParam_U32_0_PriorityGroup = NVIC_GetPriorityGrouping()

/**************************************************************
功能：便于C++程序的调用
使用方式：在进行了前面的防止重复引用步骤后，直接原样添加此部分内容即可，分为两部分，这是第二部分
**************************************************************/
#ifdef __cplusplus
}
#endif

#endif