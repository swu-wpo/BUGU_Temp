# 实现功能

此处使用文档语言记录我们需要实现的功能，以及对一些概念进行解析。为了提升效率这里只总结必须实现的功能，而更多附加功能可以在未来继续添加，同时一些功能可能设计不太完善，在未来需要继续不断完善。

考虑到效率，如果我认为比较好理解且在示例中给出的功能就只简写。本文档和示例在部分地方可能有差别，如果冲突以此处为准。从前往后阅读，如果发现不懂的地方，可以先在概念中查找，如果还是没搞懂，则来询问我。

目前只需要实现下列内容中和示例相关的部分即可。

## 前端

### 创建项目

#### 创建组件项目

1. 组件名
2. 组件Token
3. 是否为抽象组件
4. 组件ID

#### 创建工程项目

1. 工程名
2. 工程Token
3. 选择芯片
4. 设置堆栈

### 编辑组件

#### 创建类

1. 类名
2. 类Token
3. 父类
4. 继承选项：选择性继承属性
5. 唯一类开关
6. 末代类开关
7. 选择移植芯片（仅抽象组件中创建移植类时）
8. 构造方法
9. 析构方法
10. 类ID

#### 引入类

1. 上传SDK包
2. 显示SDK包文件树并可供用户选择h文件和c文件
3. 类名
4. 继承类：目前仅支持ENUM、MACRO和标准类。
5. 类Token
6. 对象基类
7. 对象名
8. 对象Token
9. 类ID

#### 创建下级组件

1. 组件名
2. 组件Token
3. 移植芯片（仅限移植组件的下级组件）

###  编辑类

#### 创建对象

1. 对象栏直接赋值
2. 构造方法中赋值
3. 对象名
4. 对象Token
5. 对象基类
6. 对象栏赋值
7. 常量对象

#### 引入对象

1. 上传SDK包
2. 显示SDK包文件树并可供用户选择h文件和c文件
3. 对象名
4. 对象基类

#### 创建本体对象

1. 说明：本体对象是用于方便用户快速使用的对象，在任何类中我们都可以以该类自己创建一个或多个本体对象，它们在其它任何类的方法中都可以直接使用，且操作的都是该对象。在C语言中，它相当于一个全局变量。但是如果这个对象没有被任何方法所使用，那么这个本体对象就不应该被生成在C代码中。本体对象和创建对象相同，但是它不会被包含在类中。

### 编辑方法

#### 创建方法

1. 方法栏中创建
2. 方法名
3. 方法Token
4. 输入形参（根据语境也可以叫副本形参）对象列表
5. 输出形参（根据语境也可以叫本体形参）对象列表：输入形参和输出形参都必须是已实例化的对象
6. 对象基类：使用方法时的实参必须和对应形参的基类相同
7. 取值区间：仅限输入参数。用户可以为参数设置取值区间，用户可以在取值区间内直接选择自己想要的选项，当然用户也可以不在取值区间内取值，但在实参不是变量的情况下，。默认情况下，浮点数或整数系列类的最大取值范围是他的最大最小值的区间，而枚举和宏则是它们的所有对象。但用户也可以在最大取值范围中间取多个子区间作为该参数对象的取值区间。
8. 默认值：仅限输入参数。开启默认值后，如果该参数基类是数据类，则可以直接在取值区间中选择一个值。而如果是标准类，则会生成一个直接传参，直接传参的内容就是该输入参数。
9. 变量方法：如果当前方法使用了变量方法，

#### 使用方法

1. 选择对象
2. 选择方法
3. 选择重载
4. 字段填入参数
5. 方法直接传参
6. 选择对象传参
7. 基础操作对象的方法

## 后端

### 解析工程

1. 通过项目Token生成工程项目文件夹
2. 通过芯片复制工具链
3. 通过芯片复制链接脚本、Makefile、启动文件、Device文件夹、CMSIS文件夹
4. 修改Makefile：添加Device、CMSIS的引用路径，添加宏定义，添加链接脚本，添加CPU、FPU、浮点处理，添加启动文件（汇编资源文件），C资源文件中添加Device中的system_stm32f4xx.c资源文件，添加项目名，添加调试和优化标志
5. 通过堆栈修改链接脚本

### 解析外部组件

1. 外部组件添加到Core中
2. 每个组件生成组件文件夹
3. 每个类生成h文件
4. 每个方法生成到c文件
5. 每个内部下级组件生成到sub下，并继续嵌套

### 解析内部组件

1. 内部组件添加到User中
2. 每个组件生成组件文件夹
3. 每个类生成h文件
4. 每个方法生成到c文件
5. 每个内部下级组件生成到sub下，并继续嵌套

### 解析类

1. 用户ID、组件ID、类ID、类Token组成文件名字
2. 如果是移植类需要添加Trans和移植芯片的后缀以及移植芯片ID
3. h文件中添加防重复宏定义和兼容C++宏定义
4. 添加引用文件
5. 声明类属性
6. 声明类对象
7. 引用方法

#### 声明类属性（标准类）

1. 生成

   ```c
   typedef struct
   {
   	数据类型 属性对象名;
   }类名;
   ```

2. 属性列表逐行填入属性对象及其数据类型

3. 属性名前缀和类名相同，在后加上属性ID、属性基类Token、属性对象Token

4. 属性基类是基础数据类，则直接生成C语言对应数据类型

5. 属性基类是ENUM或标准类，数据类型直接填入类名

6. 属性基类是ARRAY，如果限定了长度，使用定长数组，否则使用对应数据类型的指针。

7. 属性基类是STRING，数据类型填入`char*`

#### 声明类属性（基础数据类）

1. 生成

   ```c
   typedef 数据类型 类名;
   ```

   因为基础数据类只能创建副本类（即重命名），不能继承，声明这些类只需要typedef即可，没有其它东西。

#### 声明类属性（ENUM）

1. 生成

   ```c
   typedef enum
   {
   	属性对象名 = 属性值,
   }类名;
   ```

2. 属性列表逐行填入属性对象及其属性值（整数）

3. 属性名前缀和类名相同，在后加上属性ID、属性基类Token、属性对象Token

4. 属性值直接放数字即可

#### 声明类属性（MACRO）

1. 生成

   ```c
   #define 属性名 (数据类型)属性值或Token
   ```

2. 属性列表逐行填入属性名、属性值或Token及其数据类型

3. 属性名前缀和类名相同，在后加上属性ID、属性基类Token、属性对象Token

4. 属性值或Token目前只支持数据类除ENUM的类型，其中ARRAY和STRING不需要写数据类型

5. 当从外部引入属性对象时，同样不需要添加数据类型，直接写入Token即可，前端填写的数据类型是给前端用的

6. 当使用STRING时，属性值是`“字符串”`这种样式的，而ARRAY则是`{数据项1，数据项2}`这种样子的。

7. 此处STRING和ARRAY的数据项只能是基础数据类的字段，不能是一个对象

#### 引用方法

1. 将类中所有方法全部添加引用（直接复制生成函数的返回值、名字和参数表然后加一个分号换行即可）

### 解析方法

1. 每个方法生成一个c文件，c文件中装有该方法的所有重载
2. 方法格式
3. 参数强制转换
4. 基础操作对象的方法解析
5. 方法直接传参

## 概念

如果前面有看不懂的地方，就在概念中查找。

### 参数强制转换

当使用方法的时候，如果形参和实参的类不一样，前端会进行提醒，如果用户认为没有问题，则需要勾选参数强制转换，此时后端生成的时候也会加上参数强制转换语句。

### 方法格式

除了方法直接传参时创建的临时方法，其它方法一律应该使用`void`返回值。每个类中的方法函数的第一个参数都是当前所属类，然后才是在前端设置的参数，我们使用这样的格式来创建方法：

```c
void 方法名(所属类名* const this, 输入参数类名 输入形参名, 输出参数类名* 输出形参名)
{
	return;
}
```

其中void和return是必须的，而所属类名后的const是修饰指针的，以防止我们在函数中将一个对象的指针指向了另外一个地址。输入形参名和输出形参名我在示例中用的`IParam_类名_形参编号`和`OParam_类名_形参编号`，但是考虑到标准类的类名不是很方便写，所以我们直接使用`IParam_形参编号`和`OParam_形参编号`也可以。

### 指针操作

我们在传值的时候需要注意指针操作。

传递给函数的对象是结构体，所以传参时需要加上`&`取地址，而在内部操作结构体时，我们操作的是他的成员变量，作为地址取成员变量需要使用`->`取指。而因为成员变量也是作为参数在使用，所以我们需要结合两者来统一操作。

不过对于在方法中创建的对象，它们本身是值类型，所以传参的时候应该使用`.`来取成员变量。

在方法中如果是输出形参的操作，使用的其实也是地址，如果它是一个标准类，那么我们像前面一样处理即可，但如果它是一个基础数据类，我们需要根据其操作类型进行判断，如果它是作为输入形参传给了其它方法，那么应该加上取值符`*`，如果它是作为输出参数传给其它方法，则直接使用输出形参名即可，不需要加东西。

**关于ARRAY、STRING对象的处理需要特殊考虑，不过目前先不管**

### 基础操作对象

基础操作对象是一个概念上的对象，用户通过这个对象实现所有基础操作，比如计算、循环、判断等。基础操作对象在概念上继承自标准类，但只有方法没有属性，且这些方法的解析与其它标准类的解析不同，它们有单独的前端操作和后端解析方案。这里列举一些基础操作对象的方法及其解析方法。

#### 循环方法

使用循环方法重载后，会在指定位置添加两个块，分别叫做xx循环·起点和xx循环·终点，同时在两块中间的块会被后移（类似代码分段对齐），内部程序将按照一定规则进行循环执行。

##### 无限循环重载

内部程序将不断循环执行，永不停，无限循环起点将被解析为`for(;;){`而无限循环终点将被解析为`}`。

##### 条件循环重载

条件循环重载是一个变参重载，默认情况下他有三个参数，但如果有必要，它可以增加参数，每次默认增加四个参数。前三个参数中，在第一个参数中需要填入一个字段、对象或方法直接传参，第二个参数是一个符号可选字段，用于选择判断标准（大于、等于、小于、大于等于、小于等于、不等于），同时在此参数可以选择取反，选择后会自动将当前的判断内容直接取反（大于和小于等于，小于和大于等于，等于和不等于），第三个参数和第一个参数传参方式相同，而如果变参，则第四个参数是逻辑判断（与、或），而后面三个与最开始的三个相同，并以此类推。不过只能支持基础数据类以及ENUM类（ENUM类可以和基础数据类直接进行比较）的比较。解析后会被生成为`while(参数1 参数2 参数3 参数4 参数5 参数6 参数7)`，具体每个参数生成什么，需要根据具体情况来生成。

##### 计次循环重载

选定一个整数然后重复相同次，有三个参数，第一个参数可以是字段、对象或直接传参，记录循环次数，第二个参数是标志起始值，可以是字段、对象或直接传参，作为计次循环标志对象的起始值，第三个参数是跳步大小，可以是字段，默认是1，即向前跳步。在计次循环起点和终点之间，会有一个局部对象，作用域只在这里，其类型是I32，如果用户不希望使用I32，也可以在标志起始值那里勾选其它整数类（目前只能是整数类）。解析后会被生成为`for(int32_t temp = 参数2; temp 比较符 参数2 + 参数1 * 参数3; temp += 参数3)`，其中比较符是根据参数3的正负决定的，如果是正，则是`<`，否则是`>`。

###  实例化对象

从本质上，我们只会实例化核心类中的所有对象，而其他类中对象的实例化都是被嵌套在这些实例化中的。在核心类所在的h文件中，我们将以结构体包含属性（核心类是一个标准类），同时这个结构体会被创建为对象（结构体变量），然后将在核心方法（main函数）使用这些属性的构造方法（将结构体变量的对应成员以指针传给函数），而在这些构造方法中，将会继续调用该对象属性基类的构造方法，然后和前述方法一样向下构造。除此之外，还有可能出现在方法中直接创建并实例化的对象，这些对象的生成方法也是同理，只是它们会被生成在函数中并且对应的指针不同。**这里的内容未来可能需要优化，比如检查始终没有使用过的对象并在解析时将其从结构体中筛除，但目前先以这样的方式进行实现即可。**

### 添加引用文件

即后端生成h文件时include其它类的h文件。前端在某个类调用了外部其它类时，就会进行记录，而后端根据这个记录中用户ID、组件ID、类ID、类Token以及是否是移植类还有移植芯片ID来确定对应h文件的相对位置。如果是其它组件的类，就从根目录找相对位置，如果是当前组件的类或是子类，则从当前h文件所在位置开始寻找相对位置。如果调用了外部SDK的内容，还需要添加SDK中的相对位置，添加过程分为在Makefile中添加相对路径，然后从此相对路径后在类文件中添加此相对路径的相对路径。

### 侧栏

侧边栏，侧边栏中可以有两个页面——对象栏和方法栏

#### 对象栏

显示：组件、组件中类、类中属性对象、当前打开重载中创建的对象、重载参数对象、属性对象的构造方法参数对象、下级组件（嵌套）

#### 方法栏

显示：组件、组件中类、类中方法、方法中重载、重载中参数对象

### 对象栏直接赋值

本质上是快速添加构造方法，如果在对象栏为某个属性直接赋值，相当于在当前类的构造方法中添加该属性对象的构造方法，并填入参数。直接赋值时填入的数据其实就是构造方法的参数。如果参数是一个标准类的对象，那么还可以继续嵌套填入这个对象的构造方法参数。当用户在对象栏直接赋值完毕，再打开当前类的构造方法，就可以看到刚才添加的内容了。

### 方法直接传参

方法直接传参被解析后是一个有返回值的C函数作为参数直接在另一个函数中被调用，以实现不用新建对象而直接传参的效果。当用户希望使用A方法的输出实参作为B方法对应基类的输入形参的实参时，其可以在调用B方法处对应形参的选项中选择方法直接传参，然后选择希望执行A方法的对象，然后选择该对象需要执行的A方法，然后在其输出形参列表中选择一个作为直接传参参数。当然，除了直接选择已有的方法，如果我们希望实现更加丰富的操作，也可以选择新建方法。在后端，如果发现了直接传参方法，会在对应.c文件中生成一个局部函数，该函数的参数列表和B方法相同，但是会以值形式多返回一个选择的输出参数。

### 基础组件

基础组件是任何项目中都会自动添加的组件，基础组件包括了和其它组件也会有的类、方法和对象。它和前端编程界面一起，构成了BUGU平台一切编程的基础。

### 类

类是一种抽象数据类型，包含了属性和方法。在BUGU中，类分为标准类和数据类，其它类都是从这两种类中发展而来。

#### 继承

创建一个类的时候，都需要选择该类是从另一个类的继承。被继承的是父类，继承的是子类（或派生类），子类将拥有父类可以继承的所有对象和方法，但是子类也可以选择性不继承一些对象，但同时父类中出现过该对象的方法也同样不会被继承。

#### 副本类

副本类是一种特殊的继承，副本类不能选择继承，它相当于对父类的重命名。

#### 末代类

当我们不希望某个类被继承，可以选择其为末代类，此时该类将不能再被普通继承，但是仍然可以被创建副本类。默认关闭。

#### 唯一类

当我们不希望某个类被重命名，可以选择其为唯一类，此时该类将不能再创建副本类。默认开启。

#### 标准类

标准类对应了C语言的struct，生成C语言时会将所有属性包含在一个结构体中。默认情况下用户创建的类都是继承自标准类。只有标准类的子类才能创建新的方法。

#### 数据类

数据类是对一系列类的集合，它们解析方式各有不同。

##### 基础数据类

基础数据类是对数据类中一部分类的统称，它们代表了C语言中的几种基础数据类型。基础数据类不能被继承，但是可以创建副本类。

##### I8

有符号8位整数，对应uint8_t，其余同理

##### U8

无符号8位整数，对应int8_t，其余同理

##### I16

##### U16

##### I32

##### U32

##### F

单精度浮点数，对应float

##### D

双精度浮点数，对应double

##### CHAR

字符，对应char

##### 特殊数据类

数据类中除了基础数据类的部分

##### ENUM

枚举，对应enum，使用enum后将会获得一组不一定连续值的枚举项，然后用户可以给每个枚举项命名，同时每个枚举项会有自己的id。

##### MACRO

宏，类似#define（但只实现部分必须功能），在前端使用上和ENUM很类似，用户可以将数据类中除ENUM的字段定义为宏，宏的特点是传递字段而非变量，以节省内存空间。例如通过定义一组U8的字段为宏，可以实现ENUM的效果，但是不需要在内存中申请ENUM那么多空间。

##### ARRAY

数组，不能抽象，也不能继承

##### STRING

字符串，对应char数组，不能抽象，也不能继承

### 基类

使用一个基类创建一个对象。

### 所属类

一个对象或方法必须在所属类中创建。

### 属性

类中的属性必须在实例化后才可以使用其它方法，实例化前只能使用其基类的构造方法。用户可以直接在对象栏中初始化数据类对象，但这样的操作实际上是在该对象所属类的构造方法中使用了基类的构造方法，当用户打开构造方法后可以看到其中自动添加的属性构造方法。

### 方法

方法只能在其它方法中调用。

同一个类中的方法可以相互调用。

如果属性中的对象在所属类的构造函数中已实例化，则可以在所属类的其它方法中调用该对象并使用其中的方法。

可以在方法中创建对象并实例化，然后调用该对象的方法。

### Token

即之前所说的英语名。BUGU生成出C时，Token作为方便命名和查看的由英语数字下划线组成的字符串。C引入到BUGU时，Token将记录C语言中的变量、函数、宏定义等的名称，它们会被#define或typedef重命名。如果是BUGU生成C，则Token不是必填的，但是如果不填写，Token将会以对应分级的默认值占位。

### 构造方法

用于实例化对象，每个类有且只有一个构造方法，但是构造方法可以有多个重载。一个类的所有属性必须在所属类的构造方法中使用基类构造方法进行实例化。**实现构造方法重载之前必须要实现检查对象是否已实例化的功能**

### 析构方法

用于释放对象，当对象在作用域结束工作后，会执行析构方法然后释放空间（释放空间的操作是编译器做的，我们只需要在结束前执行该方法即可，该方法不需要显式执行，目前这个功能可以不用实现）

###  SDK包

包含了h和c文件的压缩文件包，将在后端被解压，并填充到生成项目文件的SDK文件夹中。

### 引用路径

添加一个路径作为引用路径，此时可以在文件中调用h文件时可以引用从该路径开始的相对路径。

### 资源文件

将c文件添加到Makefile中，只要用到了的资源文件就必须添加。

### 抽象组件

为了方便移植，在此设计了抽象组件，用户通过抽象组件来实现项目在不同平台间的快速移植。目前暂时只关注MCU间的移植。

当创建了一个抽象组件后，可以为其创建抽象类，在抽象类中提供了抽象属性和抽象方法，但抽象类中没有对抽象方法提供实现（即重载）。当用户创建了一个抽象类后，便可以以此创建一个子类，该类将对应一个芯片，我们称之为某芯片的移植类。然后用户可以在移植类中为方法创建重载，也可以根据需要创建新的属性。

当在某芯片的工程项目中使用了该抽象组件，用户将会看到该抽象组件针对该芯片的所有移植类中的内容，此时该抽象组件可以被成为该芯片的移植组件。用户可以将移植类申请为对象后使用该移植类的方法重载。

而如果当用户重新打开该工程项目后，希望将项目改为另一个芯片，此时系统将会进行扫描，之后用户将得到一个窗口，在窗口中将显示工程项目中使用过的原本移植类中所有方法重载，同时会对应上该方法重载所属抽象方法在新芯片上的所有重载，用户可以选择每组方法重载的对应关系，之后系统将自动替换这些内容。

而如果一个抽象方法在一个芯片上有重载而在另一个芯片上没有重载，用户可以选择删除该方法（也就是将原本使用该重载的地方更换为什么也没有）或为该抽象方法创建一个新的重载。

在选择完所有重载的对应关系后，系统将辅助跳转所有的功能实现，让用户为每个重载选择参数。

为了方便快速移植，用户可以选择在创建移植类的时候，为一些重载添加上默认的链接关系，这时在更换芯片后如果中间有用到这些重载，就会默认替换。同时如果重载中的参数如果是来自同一组件的抽象类，那么还可以将这些参数链接在一起，那么如果使用常量传参时，就可以直接原样传递，不过只有添加了链接的参数才会被传递。

另外，为了尽量隔离抽象和底层的实现，可以为抽象组件创建下级组件，这些下级组件用于提供一些芯片最底层的实现函数，然后供抽象组件调用。下级组件不是必须的，只是这样隔离会让程序结构更加清晰。因为抽象组件的下级组件必然是和芯片直接相关的，所以对于下级组件来说，它的上级组件也是移植组件（即不包含其它移植类的抽象组件），故此时创建下级组件还应该填入移植芯片。

### 下级组件

下级组件用于辅助上级组件的实现。添加下级组件的方式有两种：创建和链接。创建的下级组件会直接在侧边栏中显示，会和上级组件进行嵌套，类似于文件夹嵌套。而链接的下级组件则是直接从外部链接，是将外部已有的组件设置为一个组件的下级组件，该下级组件会被添加到侧边栏中，但是是直接添加到根路径下。

### 变量方法

所有数据类都至少有两个方法，即写入方法和读出方法。其中写入方法会改变对象值属性（值属性在概念上也是个对象，但是它是被后端解析程序处理的对象，它对外可以使用的方法就是写入方法和读出方法），于是我们称写入方法是一种变量方法。同时，在数据类中对类中的属性进行了改变的方法就会被我们称为变量方法，而写入方法就是最基础的变量方法。以此类推，当任何类中，某方法中出现了该类的属性对象使用了变量方法，该类就是一个变量方法。变量方法将会和常量对象冲突。变量方法不是一个手动添加的设置，而是一个被动检测且会在前端显示的标志。

### 常量对象

当我们希望一个对象的值在实例化后就不要再发生任何改变时，可以将其设置为常量对象，常量对象将不能调用任何变量方法，因为变量方法会改变常量对象中属性的值。

### ID

用户、组件、下级组件、类、方法、对象等都可以有ID，ID是自动生成的，用于在同一级路径下区分不同内容以产生不同的名字，Token和ID一般会被用于配合生成名字。

### 字段赋值

字段指的是数字、字符串、选择项、开关等输入量，是通过前端展示的赋值方法。字段赋值有点类似于常量赋值，但是这个常量不是常量对象，而就是一个常量。字段赋值有一定的限制，其赋值项必须在规定范围内，且字段赋值只支持对数据类的赋值，而标准类则需要通过数据类来间接字段赋值。

#### 取值区间

取值区间是针对方法参数而言的，输入参数可以使用字段赋值，而如果用户在定义方法的时候设置了取值区间，用户就只能在取值区间中选择或填入一个数来传参，不过用户也可以在使用方法的时候，在对应参数一行手动关闭取值区间，那么取值区间就不会限制字段赋值，用户可以在对应类的最大取值范围内选择或填入任意值。

#### I8

最大取值范围：-128到127，用户可以输入在取值区间的值来取值，也可以通过下拉栏选择数字取值，其余同理。

#### U8

最大取值范围：0到255，用户可以在取值区间的值来取值，也可以通过下拉栏选择数字取值，其余同理。

#### I16

#### U16

#### I32

#### U32

#### F

最大取值范围： 1.2E-38 到 3.4E+38，6位有效位，手动填入

#### D

最大取值范围：2.3E-308 到 1.7E+308，15位有效位，手动填入

#### CHAR

最大取值范围：单个ASCII码值，手动填入或选择

#### STRING

最大取值范围：用户设置该参数最长长度，如果没设置则可以任意长度字符串，可以手动填入字符串，可以换行但需要设置换行符类型（`\n`或`\r\n`），换行后后端会记录换行符，手动填入。

#### ARRAY

最大取值范围：用户设置该参数最长长度，如果没设置则可以任意长度数组，数组填入以表格或文字形式填入，使用文字填入时用户可以设置间隔符（比如用户可以设置`|`为间隔符，那么用户可以从外面复制很长一段内容，然后直接粘贴在文本框中，前端将自动把`|`当作不同项的填入间隔），ARRAY的项类型目前暂时仅支持基础数据类。

##### ENUM

最大取值范围：该枚举类所有的对象。用户可以填入枚举对象的ID进行选择（填入时将以列表的形式展示），也可以直接从列表中选择需要的枚举项。

#### MACRO

宏不会直接作为类型被放入参数列表，但是制作方法时，除ENUM外，作者可以将任意参数的取值区间设置为宏区间，然后选择一个宏类中的宏作为选项，此时用户就可以直接选择宏来填入内容了，如果使用了这种方式，那么原本的取值区间就会被宏来替代，有点类似于宏版的ENUM。
